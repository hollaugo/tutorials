// {{pascalCase name}} Form Widget
// Generated by chatgpt-apps-builder plugin
//
// A form widget for creating/editing {{name}} items
// with validation and error handling.

import React, { useState, useEffect } from "react";
import { createRoot } from "react-dom/client";
import {
  useToolInput,
  useToolOutput,
  useWidgetContext,
} from "../hooks";
import { cn, generateIdempotencyKey } from "../lib/utils";
import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
  CardFooter,
  Button,
  Input,
  Textarea,
  Label,
  Select,
  SelectTrigger,
  SelectValue,
  SelectContent,
  SelectItem,
  Alert,
  AlertDescription,
} from "../components/ui";
import { Loader2, AlertCircle, CheckCircle2 } from "lucide-react";

// =============================================================================
// Types
// =============================================================================

interface {{pascalCase name}}Input {
  id?: string; // Present if editing
}

interface {{pascalCase name}}Output {
  {{name}}?: {
    id: string;
    {{#each fields}}
    {{name}}: {{type}};
    {{/each}}
  };
}

interface FormData {
  {{#each fields}}
  {{name}}: {{type}};
  {{/each}}
}

interface FormErrors {
  {{#each fields}}
  {{name}}?: string;
  {{/each}}
}

// =============================================================================
// Component
// =============================================================================

function {{pascalCase name}}FormWidget() {
  const { callTool, sendFollowUp, requestDisplayMode } = useWidgetContext();
  const toolInput = useToolInput<{{pascalCase name}}Input>();
  const toolOutput = useToolOutput<{{pascalCase name}}Output>();

  const isEditing = Boolean(toolInput?.id);

  const [form, setForm] = useState<FormData>({
    {{#each fields}}
    {{name}}: {{defaultValue}},
    {{/each}}
  });
  const [errors, setErrors] = useState<FormErrors>({});
  const [submitting, setSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  // Hydrate form if editing
  useEffect(() => {
    if (toolOutput?.{{name}}) {
      setForm({
        {{#each fields}}
        {{name}}: toolOutput.{{../name}}.{{name}} ?? {{defaultValue}},
        {{/each}}
      });
    }
  }, [toolOutput]);

  const validate = (): boolean => {
    const newErrors: FormErrors = {};

    {{#each fields}}
    {{#if required}}
    if (!form.{{name}}{{#if isString}}?.trim(){{/if}}) {
      newErrors.{{name}} = "{{label}} is required";
    }
    {{/if}}
    {{#if minLength}}
    if (form.{{name}}{{#if isString}}?.trim(){{/if}}.length < {{minLength}}) {
      newErrors.{{name}} = "{{label}} must be at least {{minLength}} characters";
    }
    {{/if}}
    {{#if maxLength}}
    if (form.{{name}}{{#if isString}}?.trim(){{/if}}.length > {{maxLength}}) {
      newErrors.{{name}} = "{{label}} must be less than {{maxLength}} characters";
    }
    {{/if}}
    {{/each}}

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmitError(null);

    if (!validate()) return;

    setSubmitting(true);

    try {
      const toolName = isEditing ? "update-{{kebabCase name}}" : "create-{{kebabCase name}}";
      const args = {
        ...(isEditing && { id: toolInput!.id }),
        {{#each fields}}
        {{name}}: form.{{name}}{{#if isString}}?.trim(){{/if}},
        {{/each}}
        idempotencyKey: generateIdempotencyKey(),
      };

      await callTool(toolName, args);
      setSuccess(true);

      // Navigate back to list after short delay
      setTimeout(async () => {
        await sendFollowUp("Show the {{name}} list");
      }, 1000);
    } catch (err) {
      setSubmitError(
        err instanceof Error ? err.message : "Failed to save. Please try again."
      );
    } finally {
      setSubmitting(false);
    }
  };

  const handleCancel = async () => {
    await sendFollowUp("Show the {{name}} list");
  };

  const updateField = <K extends keyof FormData>(
    field: K,
    value: FormData[K]
  ) => {
    setForm((prev) => ({ ...prev, [field]: value }));
    if (errors[field]) {
      setErrors((prev) => ({ ...prev, [field]: undefined }));
    }
  };

  if (success) {
    return (
      <div className="widget-container p-8 bg-background text-foreground">
        <div className="text-center">
          <CheckCircle2 className="h-12 w-12 text-green-500 mx-auto mb-4" />
          <h2 className="text-lg font-semibold mb-2">
            {{titleCase name}} {isEditing ? "Updated" : "Created"}!
          </h2>
          <p className="text-muted-foreground">Redirecting to list...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="widget-container p-4 bg-background text-foreground">
      <Card>
        <CardHeader>
          <CardTitle>
            {isEditing ? "Edit" : "Create"} {{titleCase name}}
          </CardTitle>
          <CardDescription>
            {isEditing
              ? "Update the {{name}} details below"
              : "Fill in the details to create a new {{name}}"}
          </CardDescription>
        </CardHeader>

        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            {submitError && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>{submitError}</AlertDescription>
              </Alert>
            )}

            {{#each fields}}
            <div className="space-y-2">
              <Label htmlFor="{{name}}">
                {{label}}{{#if required}} *{{/if}}
              </Label>
              {{#if (eq inputType "textarea")}}
              <Textarea
                id="{{name}}"
                value={form.{{name}}}
                onChange={(e) => updateField("{{name}}", e.target.value)}
                placeholder="{{placeholder}}"
                rows={4}
                disabled={submitting}
                className={cn(errors.{{name}} && "border-destructive")}
              />
              {{else if (eq inputType "select")}}
              <Select
                value={form.{{name}}}
                onValueChange={(value) => updateField("{{name}}", value)}
                disabled={submitting}
              >
                <SelectTrigger className={cn(errors.{{name}} && "border-destructive")}>
                  <SelectValue placeholder="{{placeholder}}" />
                </SelectTrigger>
                <SelectContent>
                  {{#each options}}
                  <SelectItem value="{{value}}">{{label}}</SelectItem>
                  {{/each}}
                </SelectContent>
              </Select>
              {{else}}
              <Input
                id="{{name}}"
                type="{{inputType}}"
                value={form.{{name}}}
                onChange={(e) => updateField("{{name}}", e.target.value)}
                placeholder="{{placeholder}}"
                disabled={submitting}
                className={cn(errors.{{name}} && "border-destructive")}
              />
              {{/if}}
              {errors.{{name}} && (
                <p className="text-sm text-destructive">{errors.{{name}}}</p>
              )}
            </div>
            {{/each}}
          </CardContent>

          <CardFooter className="flex justify-end gap-3">
            <Button
              type="button"
              variant="outline"
              onClick={handleCancel}
              disabled={submitting}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={submitting}>
              {submitting && <Loader2 className="h-4 w-4 mr-2 animate-spin" />}
              {isEditing ? "Save Changes" : "Create {{titleCase name}}"}
            </Button>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
}

// =============================================================================
// Mount
// =============================================================================

const container = document.getElementById("{{kebabCase name}}-form-root");
if (container) {
  const root = createRoot(container);
  root.render(<{{pascalCase name}}FormWidget />);
}

export default {{pascalCase name}}FormWidget;
