// =============================================================================
// Environment Configuration - MUST be first
// =============================================================================
import dotenv from "dotenv";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load environment variables from .env files
// Priority: .env.local > .env (local overrides for development)
dotenv.config({ path: path.resolve(__dirname, "../.env.local") });
dotenv.config({ path: path.resolve(__dirname, "../.env") });

// =============================================================================
// Imports
// =============================================================================
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import express from "express";
import { randomUUID } from "crypto";
{{#if database}}
import { pool } from "./db/pool.js";
{{/if}}
{{#if auth}}
import { getUserSubject } from "./auth/user.js";
{{/if}}

// Import tool handlers
{{#each tools}}
import { {{camelCase name}}Handler, {{camelCase name}}Schema } from "./tools/{{kebabCase name}}.js";
{{/each}}

// Import widget bundles
{{#each widgets}}
import { {{camelCase name}}Bundle } from "./resources/{{kebabCase name}}.js";
{{/each}}

// =============================================================================
// Environment Variables
// =============================================================================
const PORT = parseInt(process.env.PORT || "3000", 10);
const HTTP_MODE = process.env.HTTP_MODE === "true" || process.argv.includes("--http");
const NODE_ENV = process.env.NODE_ENV || "development";

// Validate required environment variables
function validateEnv() {
  const required: string[] = [
    {{#if database}}
    "SUPABASE_URL",
    "SUPABASE_SERVICE_KEY",
    {{/if}}
    {{#if auth.auth0}}
    "AUTH0_DOMAIN",
    "AUTH0_CLIENT_ID",
    "AUTH0_CLIENT_SECRET",
    {{/if}}
  ];

  const missing = required.filter((key) => !process.env[key]);

  if (missing.length > 0 && NODE_ENV === "production") {
    console.error(`Missing required environment variables: ${missing.join(", ")}`);
    console.error("Please check your .env file or environment configuration.");
    process.exit(1);
  } else if (missing.length > 0) {
    console.warn(`âš ï¸  Missing environment variables: ${missing.join(", ")}`);
    console.warn("   Some features may not work. Run ./setup.sh to configure.");
  }
}

validateEnv();

// =============================================================================
// MCP Server Setup
// =============================================================================
const server = new Server(
  {
    name: "{{appName}}",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
      resources: {},
    },
  }
);

// =============================================================================
// Tool Definitions
// =============================================================================
const TOOLS = [
{{#each tools}}
  {
    name: "{{name}}",
    description: "{{description}}",
    inputSchema: {{camelCase name}}Schema,
    annotations: {
      readOnlyHint: {{readOnly}},
      destructiveHint: {{destructive}},
      openWorldHint: {{openWorld}},
      {{#if idempotent}}idempotentHint: true,{{/if}}
    },
    _meta: {
      "openai/toolInvocation/invoking": "{{invokingText}}",
      "openai/toolInvocation/invoked": "{{invokedText}}",
      {{#if widgetRef}}"openai/outputTemplate": "ui://widget/{{widgetRef}}.html",{{/if}}
    },
  },
{{/each}}
];

// =============================================================================
// Resource Definitions (Widgets)
// =============================================================================
const RESOURCES = [
{{#each widgets}}
  {
    uri: "ui://widget/{{kebabCase name}}.html",
    mimeType: "text/html+skybridge",
    name: "{{name}}",
    description: "{{description}}",
    _meta: {
      "openai/widgetDescription": "{{description}}",
      "openai/widgetPrefersBorder": true,
    },
  },
{{/each}}
];

// =============================================================================
// Tool Handlers
// =============================================================================
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: TOOLS.map(({ inputSchema, ...tool }) => ({
    ...tool,
    inputSchema: inputSchema._def ? JSON.parse(JSON.stringify(inputSchema)) : inputSchema,
  })),
}));

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  const meta = request.params._meta as Record<string, unknown> | undefined;

  {{#if auth}}
  const userSubject = getUserSubject(meta);
  {{else}}
  const userSubject = (meta?.["openai/subject"] as string) || "unknown";
  {{/if}}

  console.log(`Tool call: ${name}`, { userSubject });

  try {
    switch (name) {
{{#each tools}}
      case "{{name}}":
        return {{camelCase name}}Handler(args, userSubject, meta);
{{/each}}
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    console.error(`Tool error (${name}):`, error);
    return {
      content: [{ type: "text", text: `Error: ${error instanceof Error ? error.message : "Unknown error"}` }],
      isError: true,
    };
  }
});

// =============================================================================
// Resource Handlers (Widgets)
// =============================================================================
server.setRequestHandler(ListResourcesRequestSchema, async () => ({
  resources: RESOURCES,
}));

server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  const { uri } = request.params;

  switch (uri) {
{{#each widgets}}
    case "ui://widget/{{kebabCase name}}.html":
      return {
        contents: [{
          uri,
          mimeType: "text/html+skybridge",
          text: {{camelCase name}}Bundle,
        }],
      };
{{/each}}
    default:
      throw new Error(`Unknown resource: ${uri}`);
  }
});

// =============================================================================
// HTTP Server (for ChatGPT Connector)
// =============================================================================
if (HTTP_MODE) {
  const app = express();
  app.use(express.json());

  // Session management for MCP
  const transports = new Map<string, StreamableHTTPServerTransport>();

  // Health check endpoint
  app.get("/health", (_, res) => {
    res.json({
      status: "healthy",
      service: "{{appName}}",
      timestamp: new Date().toISOString(),
    });
  });

  // MCP endpoint
  app.all("/mcp", async (req, res) => {
    let sessionId = req.headers["mcp-session-id"] as string;

    if (req.method === "POST") {
      const isInitialize = req.body?.method === "initialize";

      if (isInitialize || !sessionId) {
        sessionId = randomUUID();
        const transport = new StreamableHTTPServerTransport({
          sessionIdGenerator: () => sessionId,
          onsessioninitialized: (id) => console.log(`Session initialized: ${id}`),
        });

        transports.set(sessionId, transport);
        transport.onclose = () => {
          console.log(`Session closed: ${sessionId}`);
          transports.delete(sessionId);
        };

        await server.connect(transport);
        await transport.handleRequest(req, res, req.body);
      } else {
        const transport = transports.get(sessionId);
        if (!transport) {
          res.status(400).json({
            jsonrpc: "2.0",
            error: { code: -32000, message: "Session not found. Send initialize request first." },
            id: req.body?.id,
          });
          return;
        }
        await transport.handleRequest(req, res, req.body);
      }
    } else if (req.method === "GET") {
      if (sessionId && transports.has(sessionId)) {
        await transports.get(sessionId)!.handleRequest(req, res);
      } else {
        res.status(400).json({ error: "Session ID required for GET requests" });
      }
    } else if (req.method === "DELETE") {
      if (sessionId && transports.has(sessionId)) {
        await transports.get(sessionId)!.close();
        transports.delete(sessionId);
        res.json({ message: "Session closed" });
      } else {
        res.status(404).json({ error: "Session not found" });
      }
    } else {
      res.status(405).json({ error: "Method not allowed" });
    }
  });

  // Start HTTP server
  app.listen(PORT, () => {
    console.log(`\nðŸš€ {{appName}}`);
    console.log(`   Environment: ${NODE_ENV}`);
    console.log(`\nðŸ“¡ Endpoints:`);
    console.log(`   Health: http://localhost:${PORT}/health`);
    console.log(`   MCP:    http://localhost:${PORT}/mcp`);
    console.log(``);
  });

} else {
  // =============================================================================
  // STDIO Mode (for MCP Inspector)
  // =============================================================================
  async function main() {
    {{#if database}}
    // Test database connection
    try {
      await pool.query("SELECT 1");
      console.error("Database connected");
    } catch (error) {
      console.error("Database connection failed:", error);
    }
    {{/if}}

    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error("{{appName}} MCP server running on stdio");
  }

  main().catch((error) => {
    console.error("Failed to start server:", error);
    process.exit(1);
  });
}

// =============================================================================
// Graceful Shutdown
// =============================================================================
process.on("SIGTERM", async () => {
  console.log("Shutting down gracefully...");
  {{#if database}}
  await pool.end();
  {{/if}}
  process.exit(0);
});

process.on("SIGINT", async () => {
  console.log("\nShutting down...");
  {{#if database}}
  await pool.end();
  {{/if}}
  process.exit(0);
});
