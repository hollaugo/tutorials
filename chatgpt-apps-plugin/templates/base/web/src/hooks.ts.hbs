// Apps SDK Hooks for {{appName}}
// Generated by chatgpt-apps-builder plugin
//
// These hooks provide reactive access to the ChatGPT Apps SDK (window.openai)
// and handle theme synchronization with shadcn/ui components.

import { useState, useEffect, useCallback, useLayoutEffect } from "react";

declare global {
  interface Window {
    openai?: {
      // Tool data
      toolInput?: unknown;
      toolOutput?: unknown;
      toolResponseMetadata?: unknown;

      // Environment
      theme?: "light" | "dark";
      displayMode?: "inline" | "fullscreen" | "pip";
      locale?: string;
      maxHeight?: number;

      // Widget state persistence
      widgetState?: unknown;
      setWidgetState?: (state: unknown) => void;

      // Actions
      requestDisplayMode?: (mode: "inline" | "fullscreen" | "pip") => Promise<void>;
      callTool?: (name: string, args: Record<string, unknown>) => Promise<unknown>;
      sendFollowUpMessage?: (options: { prompt: string }) => Promise<void>;
      requestClose?: () => void;
      notifyIntrinsicHeight?: (height: number) => void;

      // File handling
      uploadFile?: (file: File) => Promise<{ fileId: string }>;
      getFileDownloadUrl?: (options: { fileId: string }) => Promise<{ url: string }>;

      // External links
      openExternal?: (options: { href: string }) => void;
    };
  }
}

/**
 * Generic hook to access window.openai properties reactively
 */
export function useOpenAiGlobal<K extends keyof NonNullable<Window["openai"]>>(
  key: K
): NonNullable<Window["openai"]>[K] | undefined {
  const [value, setValue] = useState(() => window.openai?.[key]);

  useEffect(() => {
    const check = () => {
      const newValue = window.openai?.[key];
      setValue((prev) => (prev !== newValue ? newValue : prev));
    };

    check();
    const interval = setInterval(check, 100);
    return () => clearInterval(interval);
  }, [key]);

  return value;
}

/**
 * Get structured input passed to the tool
 */
export function useToolInput<T>(): T | undefined {
  return useOpenAiGlobal("toolInput") as T | undefined;
}

/**
 * Get structured output from the tool (for widget hydration)
 */
export function useToolOutput<T>(): T | undefined {
  return useOpenAiGlobal("toolOutput") as T | undefined;
}

/**
 * Get current theme (light/dark) and sync with document class
 * This enables shadcn/ui dark mode support
 */
export function useTheme(): "light" | "dark" {
  const theme = useOpenAiGlobal("theme") ?? "light";

  useLayoutEffect(() => {
    // Sync theme with document for Tailwind dark mode
    if (theme === "dark") {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, [theme]);

  return theme;
}

/**
 * Get current display mode
 */
export function useDisplayMode(): "inline" | "fullscreen" | "pip" {
  return useOpenAiGlobal("displayMode") ?? "inline";
}

/**
 * Request a display mode change
 */
export function useRequestDisplayMode() {
  return useCallback(async (mode: "inline" | "fullscreen" | "pip") => {
    await window.openai?.requestDisplayMode?.(mode);
  }, []);
}

/**
 * Get the maximum height for the widget
 */
export function useMaxHeight(): number | undefined {
  return useOpenAiGlobal("maxHeight");
}

/**
 * Get the user's locale
 */
export function useLocale(): string {
  return useOpenAiGlobal("locale") ?? "en-US";
}

/**
 * Persistent widget state that survives across renders
 */
export function useWidgetState<T>(initial: T): [T, (update: T | ((prev: T) => T)) => void] {
  const [state, setStateInternal] = useState<T>(() => {
    const saved = window.openai?.widgetState as T | undefined;
    return saved ?? initial;
  });

  const setState = useCallback((update: T | ((prev: T) => T)) => {
    setStateInternal((prev) => {
      const next = typeof update === "function" ? (update as (p: T) => T)(prev) : update;
      window.openai?.setWidgetState?.(next);
      return next;
    });
  }, []);

  return [state, setState];
}

/**
 * Call another MCP tool from within the widget
 */
export function useCallTool() {
  return useCallback(async <T = unknown>(
    name: string,
    args: Record<string, unknown>
  ): Promise<T | undefined> => {
    const result = await window.openai?.callTool?.(name, args);
    return result as T | undefined;
  }, []);
}

/**
 * Send a follow-up message to continue the conversation
 */
export function useSendFollowUp() {
  return useCallback(async (prompt: string) => {
    await window.openai?.sendFollowUpMessage?.({ prompt });
  }, []);
}

/**
 * Request to close the widget
 */
export function useRequestClose() {
  return useCallback(() => {
    window.openai?.requestClose?.();
  }, []);
}

/**
 * Open an external URL (must be vetted/allowlisted)
 */
export function useOpenExternal() {
  return useCallback((href: string) => {
    window.openai?.openExternal?.({ href });
  }, []);
}

/**
 * Notify the host of the widget's intrinsic height
 * Use this to prevent clipping in inline mode
 */
export function useNotifyHeight() {
  return useCallback((height: number) => {
    window.openai?.notifyIntrinsicHeight?.(height);
  }, []);
}

/**
 * Upload a file and get a fileId
 */
export function useUploadFile() {
  return useCallback(async (file: File) => {
    return window.openai?.uploadFile?.(file);
  }, []);
}

/**
 * Get a temporary download URL for a file
 */
export function useGetFileUrl() {
  return useCallback(async (fileId: string) => {
    return window.openai?.getFileDownloadUrl?.({ fileId });
  }, []);
}

/**
 * Combined hook for common widget setup
 * Returns theme, locale, display mode, and common actions
 */
export function useWidgetContext() {
  const theme = useTheme();
  const locale = useLocale();
  const displayMode = useDisplayMode();
  const maxHeight = useMaxHeight();
  const callTool = useCallTool();
  const sendFollowUp = useSendFollowUp();
  const requestDisplayMode = useRequestDisplayMode();
  const requestClose = useRequestClose();

  return {
    theme,
    locale,
    displayMode,
    maxHeight,
    callTool,
    sendFollowUp,
    requestDisplayMode,
    requestClose,
  };
}
